: 12.0188s
File: v13.py
File duration: 11.7561s (97.81%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|import sys
     2|         0|            0|            0|  0.00%|from math import gcd
     3|         0|            0|            0|  0.00%|from math import sqrt
     4|         0|            0|            0|  0.00%|from collections import defaultdict
     5|         0|            0|            0|  0.00%|import pprofile
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|RESULT = defaultdict(int)
     9|         0|            0|            0|  0.00%|MAXN = 1048576
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|
    12|         1|  2.31266e-05|  2.31266e-05|  0.00%|def preprocess():
    13|         1|  3.19481e-05|  3.19481e-05|  0.00%|    max_iter = int(sqrt(MAXN)) + 1
    14|      1025|   0.00396919|  3.87238e-06|  0.03%|    for x in range(1, max_iter):
    15|      1024|   0.00402451|  3.93018e-06|  0.03%|        xx = x * x
    16|      1024|   0.00542212|  5.29503e-06|  0.05%|        xxN = int(sqrt(MAXN - xx))
    17|    206800|     0.795342|  3.84595e-06|  6.62%|        for y in range(x + 1, max_iter + 1, 2):
    18|    206795|     0.858251|  4.15025e-06|  7.14%|            if gcd(x, y) != 1:
    19|     38906|     0.146688|  3.77032e-06|  1.22%|                continue
    20|    167889|     0.644417|  3.83835e-06|  5.36%|            if y > xxN:
    21|      1019|   0.00394201|  3.86851e-06|  0.03%|                break
    22|    166870|     0.785544|  4.70752e-06|  6.54%|            RESULT[xx + y * y] += 1
    23|   1048577|      3.85252|  3.67404e-06| 32.05%|    for i in range(1, MAXN + 1):
    24|   1048576|      4.65595|  4.44026e-06| 38.74%|        RESULT[i] += RESULT[i - 1]
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|prof = pprofile.Profile()
    28|         0|            0|            0|  0.00%|with prof():
    29|         0|            0|            0|  0.00%|    preprocess()
(call)|         1|      11.7561|      11.7561| 97.81%|# v13.py:12 preprocess
    30|         0|            0|            0|  0.00%|    for line in sys.stdin:
(call)|        87|   0.00286937|  3.29812e-05|  0.02%|# /usr/local/bin/../Cellar/python/3.7.4/bin/../Frameworks/Python.framework/Versions/3.7/lib/python3.7/codecs.py:319 decode
    31|         0|            0|            0|  0.00%|        N = int(line)
    32|         0|            0|            0|  0.00%|        print(RESULT[N])
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|prof.print_stats()
File: /usr/local/bin/../Cellar/python/3.7.4/bin/../Frameworks/Python.framework/Versions/3.7/lib/python3.7/codecs.py
File duration: 0.00286937s (0.02%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|""" codecs -- Python Codec Registry, API and helpers.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|Written by Marc-Andre Lemburg (mal@lemburg.com).
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|"""
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|import builtins
    11|         0|            0|            0|  0.00%|import sys
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|### Registry and builtin stateless codec functions
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|try:
    16|         0|            0|            0|  0.00%|    from _codecs import *
    17|         0|            0|            0|  0.00%|except ImportError as why:
    18|         0|            0|            0|  0.00%|    raise SystemError('Failed to load the builtin codecs: %s' % why)
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|__all__ = ["register", "lookup", "open", "EncodedFile", "BOM", "BOM_BE",
    21|         0|            0|            0|  0.00%|           "BOM_LE", "BOM32_BE", "BOM32_LE", "BOM64_BE", "BOM64_LE",
    22|         0|            0|            0|  0.00%|           "BOM_UTF8", "BOM_UTF16", "BOM_UTF16_LE", "BOM_UTF16_BE",
    23|         0|            0|            0|  0.00%|           "BOM_UTF32", "BOM_UTF32_LE", "BOM_UTF32_BE",
    24|         0|            0|            0|  0.00%|           "CodecInfo", "Codec", "IncrementalEncoder", "IncrementalDecoder",
    25|         0|            0|            0|  0.00%|           "StreamReader", "StreamWriter",
    26|         0|            0|            0|  0.00%|           "StreamReaderWriter", "StreamRecoder",
    27|         0|            0|            0|  0.00%|           "getencoder", "getdecoder", "getincrementalencoder",
    28|         0|            0|            0|  0.00%|           "getincrementaldecoder", "getreader", "getwriter",
    29|         0|            0|            0|  0.00%|           "encode", "decode", "iterencode", "iterdecode",
    30|         0|            0|            0|  0.00%|           "strict_errors", "ignore_errors", "replace_errors",
    31|         0|            0|            0|  0.00%|           "xmlcharrefreplace_errors",
    32|         0|            0|            0|  0.00%|           "backslashreplace_errors", "namereplace_errors",
    33|         0|            0|            0|  0.00%|           "register_error", "lookup_error"]
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|### Constants
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|#
    38|         0|            0|            0|  0.00%|# Byte Order Mark (BOM = ZERO WIDTH NO-BREAK SPACE = U+FEFF)
    39|         0|            0|            0|  0.00%|# and its possible byte string values
    40|         0|            0|            0|  0.00%|# for UTF8/UTF16/UTF32 output and little/big endian machines
    41|         0|            0|            0|  0.00%|#
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|# UTF-8
    44|         0|            0|            0|  0.00%|BOM_UTF8 = b'\xef\xbb\xbf'
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|# UTF-16, little endian
    47|         0|            0|            0|  0.00%|BOM_LE = BOM_UTF16_LE = b'\xff\xfe'
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|# UTF-16, big endian
    50|         0|            0|            0|  0.00%|BOM_BE = BOM_UTF16_BE = b'\xfe\xff'
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|# UTF-32, little endian
    53|         0|            0|            0|  0.00%|BOM_UTF32_LE = b'\xff\xfe\x00\x00'
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|# UTF-32, big endian
    56|         0|            0|            0|  0.00%|BOM_UTF32_BE = b'\x00\x00\xfe\xff'
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|if sys.byteorder == 'little':
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|    # UTF-16, native endianness
    61|         0|            0|            0|  0.00%|    BOM = BOM_UTF16 = BOM_UTF16_LE
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|    # UTF-32, native endianness
    64|         0|            0|            0|  0.00%|    BOM_UTF32 = BOM_UTF32_LE
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|else:
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|    # UTF-16, native endianness
    69|         0|            0|            0|  0.00%|    BOM = BOM_UTF16 = BOM_UTF16_BE
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|    # UTF-32, native endianness
    72|         0|            0|            0|  0.00%|    BOM_UTF32 = BOM_UTF32_BE
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|# Old broken names (don't use in new code)
    75|         0|            0|            0|  0.00%|BOM32_LE = BOM_UTF16_LE
    76|         0|            0|            0|  0.00%|BOM32_BE = BOM_UTF16_BE
    77|         0|            0|            0|  0.00%|BOM64_LE = BOM_UTF32_LE
    78|         0|            0|            0|  0.00%|BOM64_BE = BOM_UTF32_BE
    79|         0|            0|            0|  0.00%|
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|### Codec base classes (defining the API)
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|class CodecInfo(tuple):
    84|         0|            0|            0|  0.00%|    """Codec details when looking up the codec registry"""
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|    # Private API to allow Python 3.4 to blacklist the known non-Unicode
    87|         0|            0|            0|  0.00%|    # codecs in the standard library. A more general mechanism to
    88|         0|            0|            0|  0.00%|    # reliably distinguish test encodings from other codecs will hopefully
    89|         0|            0|            0|  0.00%|    # be defined for Python 3.5
    90|         0|            0|            0|  0.00%|    #
    91|         0|            0|            0|  0.00%|    # See http://bugs.python.org/issue19619
    92|         0|            0|            0|  0.00%|    _is_text_encoding = True # Assume codecs are text encodings by default
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|    def __new__(cls, encode, decode, streamreader=None, streamwriter=None,
    95|         0|            0|            0|  0.00%|        incrementalencoder=None, incrementaldecoder=None, name=None,
    96|         0|            0|            0|  0.00%|        *, _is_text_encoding=None):
    97|         0|            0|            0|  0.00%|        self = tuple.__new__(cls, (encode, decode, streamreader, streamwriter))
    98|         0|            0|            0|  0.00%|        self.name = name
    99|         0|            0|            0|  0.00%|        self.encode = encode
   100|         0|            0|            0|  0.00%|        self.decode = decode
   101|         0|            0|            0|  0.00%|        self.incrementalencoder = incrementalencoder
   102|         0|            0|            0|  0.00%|        self.incrementaldecoder = incrementaldecoder
   103|         0|            0|            0|  0.00%|        self.streamwriter = streamwriter
   104|         0|            0|            0|  0.00%|        self.streamreader = streamreader
   105|         0|            0|            0|  0.00%|        if _is_text_encoding is not None:
   106|         0|            0|            0|  0.00%|            self._is_text_encoding = _is_text_encoding
   107|         0|            0|            0|  0.00%|        return self
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|    def __repr__(self):
   110|         0|            0|            0|  0.00%|        return "<%s.%s object for encoding %s at %#x>" % \
   111|         0|            0|            0|  0.00%|                (self.__class__.__module__, self.__class__.__qualname__,
   112|         0|            0|            0|  0.00%|                 self.name, id(self))
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|class Codec:
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|    """ Defines the interface for stateless encoders/decoders.
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|        The .encode()/.decode() methods may use different error
   119|         0|            0|            0|  0.00%|        handling schemes by providing the errors argument. These
   120|         0|            0|            0|  0.00%|        string values are predefined:
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|         'strict' - raise a ValueError error (or a subclass)
   123|         0|            0|            0|  0.00%|         'ignore' - ignore the character and continue with the next
   124|         0|            0|            0|  0.00%|         'replace' - replace with a suitable replacement character;
   125|         0|            0|            0|  0.00%|                    Python will use the official U+FFFD REPLACEMENT
   126|         0|            0|            0|  0.00%|                    CHARACTER for the builtin Unicode codecs on
   127|         0|            0|            0|  0.00%|                    decoding and '?' on encoding.
   128|         0|            0|            0|  0.00%|         'surrogateescape' - replace with private code points U+DCnn.
   129|         0|            0|            0|  0.00%|         'xmlcharrefreplace' - Replace with the appropriate XML
   130|         0|            0|            0|  0.00%|                               character reference (only for encoding).
   131|         0|            0|            0|  0.00%|         'backslashreplace'  - Replace with backslashed escape sequences.
   132|         0|            0|            0|  0.00%|         'namereplace'       - Replace with \\N{...} escape sequences
   133|         0|            0|            0|  0.00%|                               (only for encoding).
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|        The set of allowed values can be extended via register_error.
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|    """
   138|         0|            0|            0|  0.00%|    def encode(self, input, errors='strict'):
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|        """ Encodes the object input and returns a tuple (output
   141|         0|            0|            0|  0.00%|            object, length consumed).
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|            errors defines the error handling to apply. It defaults to
   144|         0|            0|            0|  0.00%|            'strict' handling.
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|            The method may not store state in the Codec instance. Use
   147|         0|            0|            0|  0.00%|            StreamWriter for codecs which have to keep state in order to
   148|         0|            0|            0|  0.00%|            make encoding efficient.
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|            The encoder must be able to handle zero length input and
   151|         0|            0|            0|  0.00%|            return an empty object of the output object type in this
   152|         0|            0|            0|  0.00%|            situation.
   153|         0|            0|            0|  0.00%|
   154|         0|            0|            0|  0.00%|        """
   155|         0|            0|            0|  0.00%|        raise NotImplementedError
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|    def decode(self, input, errors='strict'):
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|        """ Decodes the object input and returns a tuple (output
   160|         0|            0|            0|  0.00%|            object, length consumed).
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|            input must be an object which provides the bf_getreadbuf
   163|         0|            0|            0|  0.00%|            buffer slot. Python strings, buffer objects and memory
   164|         0|            0|            0|  0.00%|            mapped files are examples of objects providing this slot.
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|            errors defines the error handling to apply. It defaults to
   167|         0|            0|            0|  0.00%|            'strict' handling.
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|            The method may not store state in the Codec instance. Use
   170|         0|            0|            0|  0.00%|            StreamReader for codecs which have to keep state in order to
   171|         0|            0|            0|  0.00%|            make decoding efficient.
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|            The decoder must be able to handle zero length input and
   174|         0|            0|            0|  0.00%|            return an empty object of the output object type in this
   175|         0|            0|            0|  0.00%|            situation.
   176|         0|            0|            0|  0.00%|
   177|         0|            0|            0|  0.00%|        """
   178|         0|            0|            0|  0.00%|        raise NotImplementedError
   179|         0|            0|            0|  0.00%|
   180|         0|            0|            0|  0.00%|class IncrementalEncoder(object):
   181|         0|            0|            0|  0.00%|    """
   182|         0|            0|            0|  0.00%|    An IncrementalEncoder encodes an input in multiple steps. The input can
   183|         0|            0|            0|  0.00%|    be passed piece by piece to the encode() method. The IncrementalEncoder
   184|         0|            0|            0|  0.00%|    remembers the state of the encoding process between calls to encode().
   185|         0|            0|            0|  0.00%|    """
   186|         0|            0|            0|  0.00%|    def __init__(self, errors='strict'):
   187|         0|            0|            0|  0.00%|        """
   188|         0|            0|            0|  0.00%|        Creates an IncrementalEncoder instance.
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|        The IncrementalEncoder may use different error handling schemes by
   191|         0|            0|            0|  0.00%|        providing the errors keyword argument. See the module docstring
   192|         0|            0|            0|  0.00%|        for a list of possible values.
   193|         0|            0|            0|  0.00%|        """
   194|         0|            0|            0|  0.00%|        self.errors = errors
   195|         0|            0|            0|  0.00%|        self.buffer = ""
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|    def encode(self, input, final=False):
   198|         0|            0|            0|  0.00%|        """
   199|         0|            0|            0|  0.00%|        Encodes input and returns the resulting object.
   200|         0|            0|            0|  0.00%|        """
   201|         0|            0|            0|  0.00%|        raise NotImplementedError
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|    def reset(self):
   204|         0|            0|            0|  0.00%|        """
   205|         0|            0|            0|  0.00%|        Resets the encoder to the initial state.
   206|         0|            0|            0|  0.00%|        """
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|    def getstate(self):
   209|         0|            0|            0|  0.00%|        """
   210|         0|            0|            0|  0.00%|        Return the current state of the encoder.
   211|         0|            0|            0|  0.00%|        """
   212|         0|            0|            0|  0.00%|        return 0
   213|         0|            0|            0|  0.00%|
   214|         0|            0|            0|  0.00%|    def setstate(self, state):
   215|         0|            0|            0|  0.00%|        """
   216|         0|            0|            0|  0.00%|        Set the current state of the encoder. state must have been
   217|         0|            0|            0|  0.00%|        returned by getstate().
   218|         0|            0|            0|  0.00%|        """
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|class BufferedIncrementalEncoder(IncrementalEncoder):
   221|         0|            0|            0|  0.00%|    """
   222|         0|            0|            0|  0.00%|    This subclass of IncrementalEncoder can be used as the baseclass for an
   223|         0|            0|            0|  0.00%|    incremental encoder if the encoder must keep some of the output in a
   224|         0|            0|            0|  0.00%|    buffer between calls to encode().
   225|         0|            0|            0|  0.00%|    """
   226|         0|            0|            0|  0.00%|    def __init__(self, errors='strict'):
   227|         0|            0|            0|  0.00%|        IncrementalEncoder.__init__(self, errors)
   228|         0|            0|            0|  0.00%|        # unencoded input that is kept between calls to encode()
   229|         0|            0|            0|  0.00%|        self.buffer = ""
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|    def _buffer_encode(self, input, errors, final):
   232|         0|            0|            0|  0.00%|        # Overwrite this method in subclasses: It must encode input
   233|         0|            0|            0|  0.00%|        # and return an (output, length consumed) tuple
   234|         0|            0|            0|  0.00%|        raise NotImplementedError
   235|         0|            0|            0|  0.00%|
   236|         0|            0|            0|  0.00%|    def encode(self, input, final=False):
   237|         0|            0|            0|  0.00%|        # encode input (taking the buffer into account)
   238|         0|            0|            0|  0.00%|        data = self.buffer + input
   239|         0|            0|            0|  0.00%|        (result, consumed) = self._buffer_encode(data, self.errors, final)
   240|         0|            0|            0|  0.00%|        # keep unencoded input until the next call
   241|         0|            0|            0|  0.00%|        self.buffer = data[consumed:]
   242|         0|            0|            0|  0.00%|        return result
   243|         0|            0|            0|  0.00%|
   244|         0|            0|            0|  0.00%|    def reset(self):
   245|         0|            0|            0|  0.00%|        IncrementalEncoder.reset(self)
   246|         0|            0|            0|  0.00%|        self.buffer = ""
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|    def getstate(self):
   249|         0|            0|            0|  0.00%|        return self.buffer or 0
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|    def setstate(self, state):
   252|         0|            0|            0|  0.00%|        self.buffer = state or ""
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|class IncrementalDecoder(object):
   255|         0|            0|            0|  0.00%|    """
   256|         0|            0|            0|  0.00%|    An IncrementalDecoder decodes an input in multiple steps. The input can
   257|         0|            0|            0|  0.00%|    be passed piece by piece to the decode() method. The IncrementalDecoder
   258|         0|            0|            0|  0.00%|    remembers the state of the decoding process between calls to decode().
   259|         0|            0|            0|  0.00%|    """
   260|         0|            0|            0|  0.00%|    def __init__(self, errors='strict'):
   261|         0|            0|            0|  0.00%|        """
   262|         0|            0|            0|  0.00%|        Create an IncrementalDecoder instance.
   263|         0|            0|            0|  0.00%|
   264|         0|            0|            0|  0.00%|        The IncrementalDecoder may use different error handling schemes by
   265|         0|            0|            0|  0.00%|        providing the errors keyword argument. See the module docstring
   266|         0|            0|            0|  0.00%|        for a list of possible values.
   267|         0|            0|            0|  0.00%|        """
   268|         0|            0|            0|  0.00%|        self.errors = errors
   269|         0|            0|            0|  0.00%|
   270|         0|            0|            0|  0.00%|    def decode(self, input, final=False):
   271|         0|            0|            0|  0.00%|        """
   272|         0|            0|            0|  0.00%|        Decode input and returns the resulting object.
   273|         0|            0|            0|  0.00%|        """
   274|         0|            0|            0|  0.00%|        raise NotImplementedError
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|    def reset(self):
   277|         0|            0|            0|  0.00%|        """
   278|         0|            0|            0|  0.00%|        Reset the decoder to the initial state.
   279|         0|            0|            0|  0.00%|        """
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|    def getstate(self):
   282|         0|            0|            0|  0.00%|        """
   283|         0|            0|            0|  0.00%|        Return the current state of the decoder.
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|        This must be a (buffered_input, additional_state_info) tuple.
   286|         0|            0|            0|  0.00%|        buffered_input must be a bytes object containing bytes that
   287|         0|            0|            0|  0.00%|        were passed to decode() that have not yet been converted.
   288|         0|            0|            0|  0.00%|        additional_state_info must be a non-negative integer
   289|         0|            0|            0|  0.00%|        representing the state of the decoder WITHOUT yet having
   290|         0|            0|            0|  0.00%|        processed the contents of buffered_input.  In the initial state
   291|         0|            0|            0|  0.00%|        and after reset(), getstate() must return (b"", 0).
   292|         0|            0|            0|  0.00%|        """
   293|         0|            0|            0|  0.00%|        return (b"", 0)
   294|         0|            0|            0|  0.00%|
   295|         0|            0|            0|  0.00%|    def setstate(self, state):
   296|         0|            0|            0|  0.00%|        """
   297|         0|            0|            0|  0.00%|        Set the current state of the decoder.
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|        state must have been returned by getstate().  The effect of
   300|         0|            0|            0|  0.00%|        setstate((b"", 0)) must be equivalent to reset().
   301|         0|            0|            0|  0.00%|        """
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|class BufferedIncrementalDecoder(IncrementalDecoder):
   304|         0|            0|            0|  0.00%|    """
   305|         0|            0|            0|  0.00%|    This subclass of IncrementalDecoder can be used as the baseclass for an
   306|         0|            0|            0|  0.00%|    incremental decoder if the decoder must be able to handle incomplete
   307|         0|            0|            0|  0.00%|    byte sequences.
   308|         0|            0|            0|  0.00%|    """
   309|         0|            0|            0|  0.00%|    def __init__(self, errors='strict'):
   310|         0|            0|            0|  0.00%|        IncrementalDecoder.__init__(self, errors)
   311|         0|            0|            0|  0.00%|        # undecoded input that is kept between calls to decode()
   312|         0|            0|            0|  0.00%|        self.buffer = b""
   313|         0|            0|            0|  0.00%|
   314|         0|            0|            0|  0.00%|    def _buffer_decode(self, input, errors, final):
   315|         0|            0|            0|  0.00%|        # Overwrite this method in subclasses: It must decode input
   316|         0|            0|            0|  0.00%|        # and return an (output, length consumed) tuple
   317|         0|            0|            0|  0.00%|        raise NotImplementedError
   318|         0|            0|            0|  0.00%|
   319|        87|  0.000650167|  7.47319e-06|  0.01%|    def decode(self, input, final=False):
   320|         0|            0|            0|  0.00%|        # decode input (taking the buffer into account)
   321|        87|  0.000635624|  7.30602e-06|  0.01%|        data = self.buffer + input
   322|        87|  0.000751972|  8.64336e-06|  0.01%|        (result, consumed) = self._buffer_decode(data, self.errors, final)
   323|         0|            0|            0|  0.00%|        # keep undecoded input until the next call
   324|        87|  0.000468254|  5.38223e-06|  0.00%|        self.buffer = data[consumed:]
   325|        87|   0.00036335|  4.17644e-06|  0.00%|        return result
   326|         0|            0|            0|  0.00%|
   327|         0|            0|            0|  0.00%|    def reset(self):
   328|         0|            0|            0|  0.00%|        IncrementalDecoder.reset(self)
   329|         0|            0|            0|  0.00%|        self.buffer = b""
   330|         0|            0|            0|  0.00%|
   331|         0|            0|            0|  0.00%|    def getstate(self):
   332|         0|            0|            0|  0.00%|        # additional state info is always 0
   333|         0|            0|            0|  0.00%|        return (self.buffer, 0)
   334|         0|            0|            0|  0.00%|
   335|         0|            0|            0|  0.00%|    def setstate(self, state):
   336|         0|            0|            0|  0.00%|        # ignore additional state info
   337|         0|            0|            0|  0.00%|        self.buffer = state[0]
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|#
   340|         0|            0|            0|  0.00%|# The StreamWriter and StreamReader class provide generic working
   341|         0|            0|            0|  0.00%|# interfaces which can be used to implement new encoding submodules
   342|         0|            0|            0|  0.00%|# very easily. See encodings/utf_8.py for an example on how this is
   343|         0|            0|            0|  0.00%|# done.
   344|         0|            0|            0|  0.00%|#
   345|         0|            0|            0|  0.00%|
   346|         0|            0|            0|  0.00%|class StreamWriter(Codec):
   347|         0|            0|            0|  0.00%|
   348|         0|            0|            0|  0.00%|    def __init__(self, stream, errors='strict'):
   349|         0|            0|            0|  0.00%|
   350|         0|            0|            0|  0.00%|        """ Creates a StreamWriter instance.
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|            stream must be a file-like object open for writing.
   353|         0|            0|            0|  0.00%|
   354|         0|            0|            0|  0.00%|            The StreamWriter may use different error handling
   355|         0|            0|            0|  0.00%|            schemes by providing the errors keyword argument. These
   356|         0|            0|            0|  0.00%|            parameters are predefined:
   357|         0|            0|            0|  0.00%|
   358|         0|            0|            0|  0.00%|             'strict' - raise a ValueError (or a subclass)
   359|         0|            0|            0|  0.00%|             'ignore' - ignore the character and continue with the next
   360|         0|            0|            0|  0.00%|             'replace'- replace with a suitable replacement character
   361|         0|            0|            0|  0.00%|             'xmlcharrefreplace' - Replace with the appropriate XML
   362|         0|            0|            0|  0.00%|                                   character reference.
   363|         0|            0|            0|  0.00%|             'backslashreplace'  - Replace with backslashed escape
   364|         0|            0|            0|  0.00%|                                   sequences.
   365|         0|            0|            0|  0.00%|             'namereplace'       - Replace with \\N{...} escape sequences.
   366|         0|            0|            0|  0.00%|
   367|         0|            0|            0|  0.00%|            The set of allowed parameter values can be extended via
   368|         0|            0|            0|  0.00%|            register_error.
   369|         0|            0|            0|  0.00%|        """
   370|         0|            0|            0|  0.00%|        self.stream = stream
   371|         0|            0|            0|  0.00%|        self.errors = errors
   372|         0|            0|            0|  0.00%|
   373|         0|            0|            0|  0.00%|    def write(self, object):
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|        """ Writes the object's contents encoded to self.stream.
   376|         0|            0|            0|  0.00%|        """
   377|         0|            0|            0|  0.00%|        data, consumed = self.encode(object, self.errors)
   378|         0|            0|            0|  0.00%|        self.stream.write(data)
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|    def writelines(self, list):
   381|         0|            0|            0|  0.00%|
   382|         0|            0|            0|  0.00%|        """ Writes the concatenated list of strings to the stream
   383|         0|            0|            0|  0.00%|            using .write().
   384|         0|            0|            0|  0.00%|        """
   385|         0|            0|            0|  0.00%|        self.write(''.join(list))
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|    def reset(self):
   388|         0|            0|            0|  0.00%|
   389|         0|            0|            0|  0.00%|        """ Flushes and resets the codec buffers used for keeping state.
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|            Calling this method should ensure that the data on the
   392|         0|            0|            0|  0.00%|            output is put into a clean state, that allows appending
   393|         0|            0|            0|  0.00%|            of new fresh data without having to rescan the whole
   394|         0|            0|            0|  0.00%|            stream to recover state.
   395|         0|            0|            0|  0.00%|
   396|         0|            0|            0|  0.00%|        """
   397|         0|            0|            0|  0.00%|        pass
   398|         0|            0|            0|  0.00%|
   399|         0|            0|            0|  0.00%|    def seek(self, offset, whence=0):
   400|         0|            0|            0|  0.00%|        self.stream.seek(offset, whence)
   401|         0|            0|            0|  0.00%|        if whence == 0 and offset == 0:
   402|         0|            0|            0|  0.00%|            self.reset()
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|    def __getattr__(self, name,
   405|         0|            0|            0|  0.00%|                    getattr=getattr):
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|        """ Inherit all other methods from the underlying stream.
   408|         0|            0|            0|  0.00%|        """
   409|         0|            0|            0|  0.00%|        return getattr(self.stream, name)
   410|         0|            0|            0|  0.00%|
   411|         0|            0|            0|  0.00%|    def __enter__(self):
   412|         0|            0|            0|  0.00%|        return self
   413|         0|            0|            0|  0.00%|
   414|         0|            0|            0|  0.00%|    def __exit__(self, type, value, tb):
   415|         0|            0|            0|  0.00%|        self.stream.close()
   416|         0|            0|            0|  0.00%|
   417|         0|            0|            0|  0.00%|###
   418|         0|            0|            0|  0.00%|
   419|         0|            0|            0|  0.00%|class StreamReader(Codec):
   420|         0|            0|            0|  0.00%|
   421|         0|            0|            0|  0.00%|    charbuffertype = str
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|    def __init__(self, stream, errors='strict'):
   424|         0|            0|            0|  0.00%|
   425|         0|            0|            0|  0.00%|        """ Creates a StreamReader instance.
   426|         0|            0|            0|  0.00%|
   427|         0|            0|            0|  0.00%|            stream must be a file-like object open for reading.
   428|         0|            0|            0|  0.00%|
   429|         0|            0|            0|  0.00%|            The StreamReader may use different error handling
   430|         0|            0|            0|  0.00%|            schemes by providing the errors keyword argument. These
   431|         0|            0|            0|  0.00%|            parameters are predefined:
   432|         0|            0|            0|  0.00%|
   433|         0|            0|            0|  0.00%|             'strict' - raise a ValueError (or a subclass)
   434|         0|            0|            0|  0.00%|             'ignore' - ignore the character and continue with the next
   435|         0|            0|            0|  0.00%|             'replace'- replace with a suitable replacement character
   436|         0|            0|            0|  0.00%|             'backslashreplace' - Replace with backslashed escape sequences;
   437|         0|            0|            0|  0.00%|
   438|         0|            0|            0|  0.00%|            The set of allowed parameter values can be extended via
   439|         0|            0|            0|  0.00%|            register_error.
   440|         0|            0|            0|  0.00%|        """
   441|         0|            0|            0|  0.00%|        self.stream = stream
   442|         0|            0|            0|  0.00%|        self.errors = errors
   443|         0|            0|            0|  0.00%|        self.bytebuffer = b""
   444|         0|            0|            0|  0.00%|        self._empty_charbuffer = self.charbuffertype()
   445|         0|            0|            0|  0.00%|        self.charbuffer = self._empty_charbuffer
   446|         0|            0|            0|  0.00%|        self.linebuffer = None
   447|         0|            0|            0|  0.00%|
   448|         0|            0|            0|  0.00%|    def decode(self, input, errors='strict'):
   449|         0|            0|            0|  0.00%|        raise NotImplementedError
   450|         0|            0|            0|  0.00%|
   451|         0|            0|            0|  0.00%|    def read(self, size=-1, chars=-1, firstline=False):
   452|         0|            0|            0|  0.00%|
   453|         0|            0|            0|  0.00%|        """ Decodes data from the stream self.stream and returns the
   454|         0|            0|            0|  0.00%|            resulting object.
   455|         0|            0|            0|  0.00%|
   456|         0|            0|            0|  0.00%|            chars indicates the number of decoded code points or bytes to
   457|         0|            0|            0|  0.00%|            return. read() will never return more data than requested,
   458|         0|            0|            0|  0.00%|            but it might return less, if there is not enough available.
   459|         0|            0|            0|  0.00%|
   460|         0|            0|            0|  0.00%|            size indicates the approximate maximum number of decoded
   461|         0|            0|            0|  0.00%|            bytes or code points to read for decoding. The decoder
   462|         0|            0|            0|  0.00%|            can modify this setting as appropriate. The default value
   463|         0|            0|            0|  0.00%|            -1 indicates to read and decode as much as possible.  size
   464|         0|            0|            0|  0.00%|            is intended to prevent having to decode huge files in one
   465|         0|            0|            0|  0.00%|            step.
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|            If firstline is true, and a UnicodeDecodeError happens
   468|         0|            0|            0|  0.00%|            after the first line terminator in the input only the first line
   469|         0|            0|            0|  0.00%|            will be returned, the rest of the input will be kept until the
   470|         0|            0|            0|  0.00%|            next call to read().
   471|         0|            0|            0|  0.00%|
   472|         0|            0|            0|  0.00%|            The method should use a greedy read strategy, meaning that
   473|         0|            0|            0|  0.00%|            it should read as much data as is allowed within the
   474|         0|            0|            0|  0.00%|            definition of the encoding and the given size, e.g.  if
   475|         0|            0|            0|  0.00%|            optional encoding endings or state markers are available
   476|         0|            0|            0|  0.00%|            on the stream, these should be read too.
   477|         0|            0|            0|  0.00%|        """
   478|         0|            0|            0|  0.00%|        # If we have lines cached, first merge them back into characters
   479|         0|            0|            0|  0.00%|        if self.linebuffer:
   480|         0|            0|            0|  0.00%|            self.charbuffer = self._empty_charbuffer.join(self.linebuffer)
   481|         0|            0|            0|  0.00%|            self.linebuffer = None
   482|         0|            0|            0|  0.00%|
   483|         0|            0|            0|  0.00%|        if chars < 0:
   484|         0|            0|            0|  0.00%|            # For compatibility with other read() methods that take a
   485|         0|            0|            0|  0.00%|            # single argument
   486|         0|            0|            0|  0.00%|            chars = size
   487|         0|            0|            0|  0.00%|
   488|         0|            0|            0|  0.00%|        # read until we get the required number of characters (if available)
   489|         0|            0|            0|  0.00%|        while True:
   490|         0|            0|            0|  0.00%|            # can the request be satisfied from the character buffer?
   491|         0|            0|            0|  0.00%|            if chars >= 0:
   492|         0|            0|            0|  0.00%|                if len(self.charbuffer) >= chars:
   493|         0|            0|            0|  0.00%|                    break
   494|         0|            0|            0|  0.00%|            # we need more data
   495|         0|            0|            0|  0.00%|            if size < 0:
   496|         0|            0|            0|  0.00%|                newdata = self.stream.read()
   497|         0|            0|            0|  0.00%|            else:
   498|         0|            0|            0|  0.00%|                newdata = self.stream.read(size)
   499|         0|            0|            0|  0.00%|            # decode bytes (those remaining from the last call included)
   500|         0|            0|            0|  0.00%|            data = self.bytebuffer + newdata
   501|         0|            0|            0|  0.00%|            if not data:
   502|         0|            0|            0|  0.00%|                break
   503|         0|            0|            0|  0.00%|            try:
   504|         0|            0|            0|  0.00%|                newchars, decodedbytes = self.decode(data, self.errors)
   505|         0|            0|            0|  0.00%|            except UnicodeDecodeError as exc:
   506|         0|            0|            0|  0.00%|                if firstline:
   507|         0|            0|            0|  0.00%|                    newchars, decodedbytes = \
   508|         0|            0|            0|  0.00%|                        self.decode(data[:exc.start], self.errors)
   509|         0|            0|            0|  0.00%|                    lines = newchars.splitlines(keepends=True)
   510|         0|            0|            0|  0.00%|                    if len(lines)<=1:
   511|         0|            0|            0|  0.00%|                        raise
   512|         0|            0|            0|  0.00%|                else:
   513|         0|            0|            0|  0.00%|                    raise
   514|         0|            0|            0|  0.00%|            # keep undecoded bytes until the next call
   515|         0|            0|            0|  0.00%|            self.bytebuffer = data[decodedbytes:]
   516|         0|            0|            0|  0.00%|            # put new characters in the character buffer
   517|         0|            0|            0|  0.00%|            self.charbuffer += newchars
   518|         0|            0|            0|  0.00%|            # there was no data available
   519|         0|            0|            0|  0.00%|            if not newdata:
   520|         0|            0|            0|  0.00%|                break
   521|         0|            0|            0|  0.00%|        if chars < 0:
   522|         0|            0|            0|  0.00%|            # Return everything we've got
   523|         0|            0|            0|  0.00%|            result = self.charbuffer
   524|         0|            0|            0|  0.00%|            self.charbuffer = self._empty_charbuffer
   525|         0|            0|            0|  0.00%|        else:
   526|         0|            0|            0|  0.00%|            # Return the first chars characters
   527|         0|            0|            0|  0.00%|            result = self.charbuffer[:chars]
   528|         0|            0|            0|  0.00%|            self.charbuffer = self.charbuffer[chars:]
   529|         0|            0|            0|  0.00%|        return result
   530|         0|            0|            0|  0.00%|
   531|         0|            0|            0|  0.00%|    def readline(self, size=None, keepends=True):
   532|         0|            0|            0|  0.00%|
   533|         0|            0|            0|  0.00%|        """ Read one line from the input stream and return the
   534|         0|            0|            0|  0.00%|            decoded data.
   535|         0|            0|            0|  0.00%|
   536|         0|            0|            0|  0.00%|            size, if given, is passed as size argument to the
   537|         0|            0|            0|  0.00%|            read() method.
   538|         0|            0|            0|  0.00%|
   539|         0|            0|            0|  0.00%|        """
   540|         0|            0|            0|  0.00%|        # If we have lines cached from an earlier read, return
   541|         0|            0|            0|  0.00%|        # them unconditionally
   542|         0|            0|            0|  0.00%|        if self.linebuffer:
   543|         0|            0|            0|  0.00%|            line = self.linebuffer[0]
   544|         0|            0|            0|  0.00%|            del self.linebuffer[0]
   545|         0|            0|            0|  0.00%|            if len(self.linebuffer) == 1:
   546|         0|            0|            0|  0.00%|                # revert to charbuffer mode; we might need more data
   547|         0|            0|            0|  0.00%|                # next time
   548|         0|            0|            0|  0.00%|                self.charbuffer = self.linebuffer[0]
   549|         0|            0|            0|  0.00%|                self.linebuffer = None
   550|         0|            0|            0|  0.00%|            if not keepends:
   551|         0|            0|            0|  0.00%|                line = line.splitlines(keepends=False)[0]
   552|         0|            0|            0|  0.00%|            return line
   553|         0|            0|            0|  0.00%|
   554|         0|            0|            0|  0.00%|        readsize = size or 72
   555|         0|            0|            0|  0.00%|        line = self._empty_charbuffer
   556|         0|            0|            0|  0.00%|        # If size is given, we call read() only once
   557|         0|            0|            0|  0.00%|        while True:
   558|         0|            0|            0|  0.00%|            data = self.read(readsize, firstline=True)
   559|         0|            0|            0|  0.00%|            if data:
   560|         0|            0|            0|  0.00%|                # If we're at a "\r" read one extra character (which might
   561|         0|            0|            0|  0.00%|                # be a "\n") to get a proper line ending. If the stream is
   562|         0|            0|            0|  0.00%|                # temporarily exhausted we return the wrong line ending.
   563|         0|            0|            0|  0.00%|                if (isinstance(data, str) and data.endswith("\r")) or \
   564|         0|            0|            0|  0.00%|                   (isinstance(data, bytes) and data.endswith(b"\r")):
   565|         0|            0|            0|  0.00%|                    data += self.read(size=1, chars=1)
   566|         0|            0|            0|  0.00%|
   567|         0|            0|            0|  0.00%|            line += data
   568|         0|            0|            0|  0.00%|            lines = line.splitlines(keepends=True)
   569|         0|            0|            0|  0.00%|            if lines:
   570|         0|            0|            0|  0.00%|                if len(lines) > 1:
   571|         0|            0|            0|  0.00%|                    # More than one line result; the first line is a full line
   572|         0|            0|            0|  0.00%|                    # to return
   573|         0|            0|            0|  0.00%|                    line = lines[0]
   574|         0|            0|            0|  0.00%|                    del lines[0]
   575|         0|            0|            0|  0.00%|                    if len(lines) > 1:
   576|         0|            0|            0|  0.00%|                        # cache the remaining lines
   577|         0|            0|            0|  0.00%|                        lines[-1] += self.charbuffer
   578|         0|            0|            0|  0.00%|                        self.linebuffer = lines
   579|         0|            0|            0|  0.00%|                        self.charbuffer = None
   580|         0|            0|            0|  0.00%|                    else:
   581|         0|            0|            0|  0.00%|                        # only one remaining line, put it back into charbuffer
   582|         0|            0|            0|  0.00%|                        self.charbuffer = lines[0] + self.charbuffer
   583|         0|            0|            0|  0.00%|                    if not keepends:
   584|         0|            0|            0|  0.00%|                        line = line.splitlines(keepends=False)[0]
   585|         0|            0|            0|  0.00%|                    break
   586|         0|            0|            0|  0.00%|                line0withend = lines[0]
   587|         0|            0|            0|  0.00%|                line0withoutend = lines[0].splitlines(keepends=False)[0]
   588|         0|            0|            0|  0.00%|                if line0withend != line0withoutend: # We really have a line end
   589|         0|            0|            0|  0.00%|                    # Put the rest back together and keep it until the next call
   590|         0|            0|            0|  0.00%|                    self.charbuffer = self._empty_charbuffer.join(lines[1:]) + \
   591|         0|            0|            0|  0.00%|                                      self.charbuffer
   592|         0|            0|            0|  0.00%|                    if keepends:
   593|         0|            0|            0|  0.00%|                        line = line0withend
   594|         0|            0|            0|  0.00%|                    else:
   595|         0|            0|            0|  0.00%|                        line = line0withoutend
   596|         0|            0|            0|  0.00%|                    break
   597|         0|            0|            0|  0.00%|            # we didn't get anything or this was our only try
   598|         0|            0|            0|  0.00%|            if not data or size is not None:
   599|         0|            0|            0|  0.00%|                if line and not keepends:
   600|         0|            0|            0|  0.00%|                    line = line.splitlines(keepends=False)[0]
   601|         0|            0|            0|  0.00%|                break
   602|         0|            0|            0|  0.00%|            if readsize < 8000:
   603|         0|            0|            0|  0.00%|                readsize *= 2
   604|         0|            0|            0|  0.00%|        return line
   605|         0|            0|            0|  0.00%|
   606|         0|            0|            0|  0.00%|    def readlines(self, sizehint=None, keepends=True):
   607|         0|            0|            0|  0.00%|
   608|         0|            0|            0|  0.00%|        """ Read all lines available on the input stream
   609|         0|            0|            0|  0.00%|            and return them as a list.
   610|         0|            0|            0|  0.00%|
   611|         0|            0|            0|  0.00%|            Line breaks are implemented using the codec's decoder
   612|         0|            0|            0|  0.00%|            method and are included in the list entries.
   613|         0|            0|            0|  0.00%|
   614|         0|            0|            0|  0.00%|            sizehint, if given, is ignored since there is no efficient
   615|         0|            0|            0|  0.00%|            way to finding the true end-of-line.
   616|         0|            0|            0|  0.00%|
   617|         0|            0|            0|  0.00%|        """
   618|         0|            0|            0|  0.00%|        data = self.read()
   619|         0|            0|            0|  0.00%|        return data.splitlines(keepends)
   620|         0|            0|            0|  0.00%|
   621|         0|            0|            0|  0.00%|    def reset(self):
   622|         0|            0|            0|  0.00%|
   623|         0|            0|            0|  0.00%|        """ Resets the codec buffers used for keeping state.
   624|         0|            0|            0|  0.00%|
   625|         0|            0|            0|  0.00%|            Note that no stream repositioning should take place.
   626|         0|            0|            0|  0.00%|            This method is primarily intended to be able to recover
   627|         0|            0|            0|  0.00%|            from decoding errors.
   628|         0|            0|            0|  0.00%|
   629|         0|            0|            0|  0.00%|        """
   630|         0|            0|            0|  0.00%|        self.bytebuffer = b""
   631|         0|            0|            0|  0.00%|        self.charbuffer = self._empty_charbuffer
   632|         0|            0|            0|  0.00%|        self.linebuffer = None
   633|         0|            0|            0|  0.00%|
   634|         0|            0|            0|  0.00%|    def seek(self, offset, whence=0):
   635|         0|            0|            0|  0.00%|        """ Set the input stream's current position.
   636|         0|            0|            0|  0.00%|
   637|         0|            0|            0|  0.00%|            Resets the codec buffers used for keeping state.
   638|         0|            0|            0|  0.00%|        """
   639|         0|            0|            0|  0.00%|        self.stream.seek(offset, whence)
   640|         0|            0|            0|  0.00%|        self.reset()
   641|         0|            0|            0|  0.00%|
   642|         0|            0|            0|  0.00%|    def __next__(self):
   643|         0|            0|            0|  0.00%|
   644|         0|            0|            0|  0.00%|        """ Return the next decoded line from the input stream."""
   645|         0|            0|            0|  0.00%|        line = self.readline()
   646|         0|            0|            0|  0.00%|        if line:
   647|         0|            0|            0|  0.00%|            return line
   648|         0|            0|            0|  0.00%|        raise StopIteration
   649|         0|            0|            0|  0.00%|
   650|         0|            0|            0|  0.00%|    def __iter__(self):
   651|         0|            0|            0|  0.00%|        return self
   652|         0|            0|            0|  0.00%|
   653|         0|            0|            0|  0.00%|    def __getattr__(self, name,
   654|         0|            0|            0|  0.00%|                    getattr=getattr):
   655|         0|            0|            0|  0.00%|
   656|         0|            0|            0|  0.00%|        """ Inherit all other methods from the underlying stream.
   657|         0|            0|            0|  0.00%|        """
   658|         0|            0|            0|  0.00%|        return getattr(self.stream, name)
   659|         0|            0|            0|  0.00%|
   660|         0|            0|            0|  0.00%|    def __enter__(self):
   661|         0|            0|            0|  0.00%|        return self
   662|         0|            0|            0|  0.00%|
   663|         0|            0|            0|  0.00%|    def __exit__(self, type, value, tb):
   664|         0|            0|            0|  0.00%|        self.stream.close()
   665|         0|            0|            0|  0.00%|
   666|         0|            0|            0|  0.00%|###
   667|         0|            0|            0|  0.00%|
   668|         0|            0|            0|  0.00%|class StreamReaderWriter:
   669|         0|            0|            0|  0.00%|
   670|         0|            0|            0|  0.00%|    """ StreamReaderWriter instances allow wrapping streams which
   671|         0|            0|            0|  0.00%|        work in both read and write modes.
   672|         0|            0|            0|  0.00%|
   673|         0|            0|            0|  0.00%|        The design is such that one can use the factory functions
   674|         0|            0|            0|  0.00%|        returned by the codec.lookup() function to construct the
   675|         0|            0|            0|  0.00%|        instance.
   676|         0|            0|            0|  0.00%|
   677|         0|            0|            0|  0.00%|    """
   678|         0|            0|            0|  0.00%|    # Optional attributes set by the file wrappers below
   679|         0|            0|            0|  0.00%|    encoding = 'unknown'
   680|         0|            0|            0|  0.00%|
   681|         0|            0|            0|  0.00%|    def __init__(self, stream, Reader, Writer, errors='strict'):
   682|         0|            0|            0|  0.00%|
   683|         0|            0|            0|  0.00%|        """ Creates a StreamReaderWriter instance.
   684|         0|            0|            0|  0.00%|
   685|         0|            0|            0|  0.00%|            stream must be a Stream-like object.
   686|         0|            0|            0|  0.00%|
   687|         0|            0|            0|  0.00%|            Reader, Writer must be factory functions or classes
   688|         0|            0|            0|  0.00%|            providing the StreamReader, StreamWriter interface resp.
   689|         0|            0|            0|  0.00%|
   690|         0|            0|            0|  0.00%|            Error handling is done in the same way as defined for the
   691|         0|            0|            0|  0.00%|            StreamWriter/Readers.
   692|         0|            0|            0|  0.00%|
   693|         0|            0|            0|  0.00%|        """
   694|         0|            0|            0|  0.00%|        self.stream = stream
   695|         0|            0|            0|  0.00%|        self.reader = Reader(stream, errors)
   696|         0|            0|            0|  0.00%|        self.writer = Writer(stream, errors)
   697|         0|            0|            0|  0.00%|        self.errors = errors
   698|         0|            0|            0|  0.00%|
   699|         0|            0|            0|  0.00%|    def read(self, size=-1):
   700|         0|            0|            0|  0.00%|
   701|         0|            0|            0|  0.00%|        return self.reader.read(size)
   702|         0|            0|            0|  0.00%|
   703|         0|            0|            0|  0.00%|    def readline(self, size=None):
   704|         0|            0|            0|  0.00%|
   705|         0|            0|            0|  0.00%|        return self.reader.readline(size)
   706|         0|            0|            0|  0.00%|
   707|         0|            0|            0|  0.00%|    def readlines(self, sizehint=None):
   708|         0|            0|            0|  0.00%|
   709|         0|            0|            0|  0.00%|        return self.reader.readlines(sizehint)
   710|         0|            0|            0|  0.00%|
   711|         0|            0|            0|  0.00%|    def __next__(self):
   712|         0|            0|            0|  0.00%|
   713|         0|            0|            0|  0.00%|        """ Return the next decoded line from the input stream."""
   714|         0|            0|            0|  0.00%|        return next(self.reader)
   715|         0|            0|            0|  0.00%|
   716|         0|            0|            0|  0.00%|    def __iter__(self):
   717|         0|            0|            0|  0.00%|        return self
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|    def write(self, data):
   720|         0|            0|            0|  0.00%|
   721|         0|            0|            0|  0.00%|        return self.writer.write(data)
   722|         0|            0|            0|  0.00%|
   723|         0|            0|            0|  0.00%|    def writelines(self, list):
   724|         0|            0|            0|  0.00%|
   725|         0|            0|            0|  0.00%|        return self.writer.writelines(list)
   726|         0|            0|            0|  0.00%|
   727|         0|            0|            0|  0.00%|    def reset(self):
   728|         0|            0|            0|  0.00%|
   729|         0|            0|            0|  0.00%|        self.reader.reset()
   730|         0|            0|            0|  0.00%|        self.writer.reset()
   731|         0|            0|            0|  0.00%|
   732|         0|            0|            0|  0.00%|    def seek(self, offset, whence=0):
   733|         0|            0|            0|  0.00%|        self.stream.seek(offset, whence)
   734|         0|            0|            0|  0.00%|        self.reader.reset()
   735|         0|            0|            0|  0.00%|        if whence == 0 and offset == 0:
   736|         0|            0|            0|  0.00%|            self.writer.reset()
   737|         0|            0|            0|  0.00%|
   738|         0|            0|            0|  0.00%|    def __getattr__(self, name,
   739|         0|            0|            0|  0.00%|                    getattr=getattr):
   740|         0|            0|            0|  0.00%|
   741|         0|            0|            0|  0.00%|        """ Inherit all other methods from the underlying stream.
   742|         0|            0|            0|  0.00%|        """
   743|         0|            0|            0|  0.00%|        return getattr(self.stream, name)
   744|         0|            0|            0|  0.00%|
   745|         0|            0|            0|  0.00%|    # these are needed to make "with StreamReaderWriter(...)" work properly
   746|         0|            0|            0|  0.00%|
   747|         0|            0|            0|  0.00%|    def __enter__(self):
   748|         0|            0|            0|  0.00%|        return self
   749|         0|            0|            0|  0.00%|
   750|         0|            0|            0|  0.00%|    def __exit__(self, type, value, tb):
   751|         0|            0|            0|  0.00%|        self.stream.close()
   752|         0|            0|            0|  0.00%|
   753|         0|            0|            0|  0.00%|###
   754|         0|            0|            0|  0.00%|
   755|         0|            0|            0|  0.00%|class StreamRecoder:
   756|         0|            0|            0|  0.00%|
   757|         0|            0|            0|  0.00%|    """ StreamRecoder instances translate data from one encoding to another.
   758|         0|            0|            0|  0.00%|
   759|         0|            0|            0|  0.00%|        They use the complete set of APIs returned by the
   760|         0|            0|            0|  0.00%|        codecs.lookup() function to implement their task.
   761|         0|            0|            0|  0.00%|
   762|         0|            0|            0|  0.00%|        Data written to the StreamRecoder is first decoded into an
   763|         0|            0|            0|  0.00%|        intermediate format (depending on the "decode" codec) and then
   764|         0|            0|            0|  0.00%|        written to the underlying stream using an instance of the provided
   765|         0|            0|            0|  0.00%|        Writer class.
   766|         0|            0|            0|  0.00%|
   767|         0|            0|            0|  0.00%|        In the other direction, data is read from the underlying stream using
   768|         0|            0|            0|  0.00%|        a Reader instance and then encoded and returned to the caller.
   769|         0|            0|            0|  0.00%|
   770|         0|            0|            0|  0.00%|    """
   771|         0|            0|            0|  0.00%|    # Optional attributes set by the file wrappers below
   772|         0|            0|            0|  0.00%|    data_encoding = 'unknown'
   773|         0|            0|            0|  0.00%|    file_encoding = 'unknown'
   774|         0|            0|            0|  0.00%|
   775|         0|            0|            0|  0.00%|    def __init__(self, stream, encode, decode, Reader, Writer,
   776|         0|            0|            0|  0.00%|                 errors='strict'):
   777|         0|            0|            0|  0.00%|
   778|         0|            0|            0|  0.00%|        """ Creates a StreamRecoder instance which implements a two-way
   779|         0|            0|            0|  0.00%|            conversion: encode and decode work on the frontend (the
   780|         0|            0|            0|  0.00%|            data visible to .read() and .write()) while Reader and Writer
   781|         0|            0|            0|  0.00%|            work on the backend (the data in stream).
   782|         0|            0|            0|  0.00%|
   783|         0|            0|            0|  0.00%|            You can use these objects to do transparent
   784|         0|            0|            0|  0.00%|            transcodings from e.g. latin-1 to utf-8 and back.
   785|         0|            0|            0|  0.00%|
   786|         0|            0|            0|  0.00%|            stream must be a file-like object.
   787|         0|            0|            0|  0.00%|
   788|         0|            0|            0|  0.00%|            encode and decode must adhere to the Codec interface; Reader and
   789|         0|            0|            0|  0.00%|            Writer must be factory functions or classes providing the
   790|         0|            0|            0|  0.00%|            StreamReader and StreamWriter interfaces resp.
   791|         0|            0|            0|  0.00%|
   792|         0|            0|            0|  0.00%|            Error handling is done in the same way as defined for the
   793|         0|            0|            0|  0.00%|            StreamWriter/Readers.
   794|         0|            0|            0|  0.00%|
   795|         0|            0|            0|  0.00%|        """
   796|         0|            0|            0|  0.00%|        self.stream = stream
   797|         0|            0|            0|  0.00%|        self.encode = encode
   798|         0|            0|            0|  0.00%|        self.decode = decode
   799|         0|            0|            0|  0.00%|        self.reader = Reader(stream, errors)
   800|         0|            0|            0|  0.00%|        self.writer = Writer(stream, errors)
   801|         0|            0|            0|  0.00%|        self.errors = errors
   802|         0|            0|            0|  0.00%|
   803|         0|            0|            0|  0.00%|    def read(self, size=-1):
   804|         0|            0|            0|  0.00%|
   805|         0|            0|            0|  0.00%|        data = self.reader.read(size)
   806|         0|            0|            0|  0.00%|        data, bytesencoded = self.encode(data, self.errors)
   807|         0|            0|            0|  0.00%|        return data
   808|         0|            0|            0|  0.00%|
   809|         0|            0|            0|  0.00%|    def readline(self, size=None):
   810|         0|            0|            0|  0.00%|
   811|         0|            0|            0|  0.00%|        if size is None:
   812|         0|            0|            0|  0.00%|            data = self.reader.readline()
   813|         0|            0|            0|  0.00%|        else:
   814|         0|            0|            0|  0.00%|            data = self.reader.readline(size)
   815|         0|            0|            0|  0.00%|        data, bytesencoded = self.encode(data, self.errors)
   816|         0|            0|            0|  0.00%|        return data
   817|         0|            0|            0|  0.00%|
   818|         0|            0|            0|  0.00%|    def readlines(self, sizehint=None):
   819|         0|            0|            0|  0.00%|
   820|         0|            0|            0|  0.00%|        data = self.reader.read()
   821|         0|            0|            0|  0.00%|        data, bytesencoded = self.encode(data, self.errors)
   822|         0|            0|            0|  0.00%|        return data.splitlines(keepends=True)
   823|         0|            0|            0|  0.00%|
   824|         0|            0|            0|  0.00%|    def __next__(self):
   825|         0|            0|            0|  0.00%|
   826|         0|            0|            0|  0.00%|        """ Return the next decoded line from the input stream."""
   827|         0|            0|            0|  0.00%|        data = next(self.reader)
   828|         0|            0|            0|  0.00%|        data, bytesencoded = self.encode(data, self.errors)
   829|         0|            0|            0|  0.00%|        return data
   830|         0|            0|            0|  0.00%|
   831|         0|            0|            0|  0.00%|    def __iter__(self):
   832|         0|            0|            0|  0.00%|        return self
   833|         0|            0|            0|  0.00%|
   834|         0|            0|            0|  0.00%|    def write(self, data):
   835|         0|            0|            0|  0.00%|
   836|         0|            0|            0|  0.00%|        data, bytesdecoded = self.decode(data, self.errors)
   837|         0|            0|            0|  0.00%|        return self.writer.write(data)
   838|         0|            0|            0|  0.00%|
   839|         0|            0|            0|  0.00%|    def writelines(self, list):
   840|         0|            0|            0|  0.00%|
   841|         0|            0|            0|  0.00%|        data = b''.join(list)
   842|         0|            0|            0|  0.00%|        data, bytesdecoded = self.decode(data, self.errors)
   843|         0|            0|            0|  0.00%|        return self.writer.write(data)
   844|         0|            0|            0|  0.00%|
   845|         0|            0|            0|  0.00%|    def reset(self):
   846|         0|            0|            0|  0.00%|
   847|         0|            0|            0|  0.00%|        self.reader.reset()
   848|         0|            0|            0|  0.00%|        self.writer.reset()
   849|         0|            0|            0|  0.00%|
   850|         0|            0|            0|  0.00%|    def seek(self, offset, whence=0):
   851|         0|            0|            0|  0.00%|        # Seeks must be propagated to both the readers and writers
   852|         0|            0|            0|  0.00%|        # as they might need to reset their internal buffers.
   853|         0|            0|            0|  0.00%|        self.reader.seek(offset, whence)
   854|         0|            0|            0|  0.00%|        self.writer.seek(offset, whence)
   855|         0|            0|            0|  0.00%|
   856|         0|            0|            0|  0.00%|    def __getattr__(self, name,
   857|         0|            0|            0|  0.00%|                    getattr=getattr):
   858|         0|            0|            0|  0.00%|
   859|         0|            0|            0|  0.00%|        """ Inherit all other methods from the underlying stream.
   860|         0|            0|            0|  0.00%|        """
   861|         0|            0|            0|  0.00%|        return getattr(self.stream, name)
   862|         0|            0|            0|  0.00%|
   863|         0|            0|            0|  0.00%|    def __enter__(self):
   864|         0|            0|            0|  0.00%|        return self
   865|         0|            0|            0|  0.00%|
   866|         0|            0|            0|  0.00%|    def __exit__(self, type, value, tb):
   867|         0|            0|            0|  0.00%|        self.stream.close()
   868|         0|            0|            0|  0.00%|
   869|         0|            0|            0|  0.00%|### Shortcuts
   870|         0|            0|            0|  0.00%|
   871|         0|            0|            0|  0.00%|def open(filename, mode='r', encoding=None, errors='strict', buffering=1):
   872|         0|            0|            0|  0.00%|
   873|         0|            0|            0|  0.00%|    """ Open an encoded file using the given mode and return
   874|         0|            0|            0|  0.00%|        a wrapped version providing transparent encoding/decoding.
   875|         0|            0|            0|  0.00%|
   876|         0|            0|            0|  0.00%|        Note: The wrapped version will only accept the object format
   877|         0|            0|            0|  0.00%|        defined by the codecs, i.e. Unicode objects for most builtin
   878|         0|            0|            0|  0.00%|        codecs. Output is also codec dependent and will usually be
   879|         0|            0|            0|  0.00%|        Unicode as well.
   880|         0|            0|            0|  0.00%|
   881|         0|            0|            0|  0.00%|        Underlying encoded files are always opened in binary mode.
   882|         0|            0|            0|  0.00%|        The default file mode is 'r', meaning to open the file in read mode.
   883|         0|            0|            0|  0.00%|
   884|         0|            0|            0|  0.00%|        encoding specifies the encoding which is to be used for the
   885|         0|            0|            0|  0.00%|        file.
   886|         0|            0|            0|  0.00%|
   887|         0|            0|            0|  0.00%|        errors may be given to define the error handling. It defaults
   888|         0|            0|            0|  0.00%|        to 'strict' which causes ValueErrors to be raised in case an
   889|         0|            0|            0|  0.00%|        encoding error occurs.
   890|         0|            0|            0|  0.00%|
   891|         0|            0|            0|  0.00%|        buffering has the same meaning as for the builtin open() API.
   892|         0|            0|            0|  0.00%|        It defaults to line buffered.
   893|         0|            0|            0|  0.00%|
   894|         0|            0|            0|  0.00%|        The returned wrapped file object provides an extra attribute
   895|         0|            0|            0|  0.00%|        .encoding which allows querying the used encoding. This
   896|         0|            0|            0|  0.00%|        attribute is only available if an encoding was specified as
   897|         0|            0|            0|  0.00%|        parameter.
   898|         0|            0|            0|  0.00%|
   899|         0|            0|            0|  0.00%|    """
   900|         0|            0|            0|  0.00%|    if encoding is not None and \
   901|         0|            0|            0|  0.00%|       'b' not in mode:
   902|         0|            0|            0|  0.00%|        # Force opening of the file in binary mode
   903|         0|            0|            0|  0.00%|        mode = mode + 'b'
   904|         0|            0|            0|  0.00%|    file = builtins.open(filename, mode, buffering)
   905|         0|            0|            0|  0.00%|    if encoding is None:
   906|         0|            0|            0|  0.00%|        return file
   907|         0|            0|            0|  0.00%|    info = lookup(encoding)
   908|         0|            0|            0|  0.00%|    srw = StreamReaderWriter(file, info.streamreader, info.streamwriter, errors)
   909|         0|            0|            0|  0.00%|    # Add attributes to simplify introspection
   910|         0|            0|            0|  0.00%|    srw.encoding = encoding
   911|         0|            0|            0|  0.00%|    return srw
   912|         0|            0|            0|  0.00%|
   913|         0|            0|            0|  0.00%|def EncodedFile(file, data_encoding, file_encoding=None, errors='strict'):
   914|         0|            0|            0|  0.00%|
   915|         0|            0|            0|  0.00%|    """ Return a wrapped version of file which provides transparent
   916|         0|            0|            0|  0.00%|        encoding translation.
   917|         0|            0|            0|  0.00%|
   918|         0|            0|            0|  0.00%|        Data written to the wrapped file is decoded according
   919|         0|            0|            0|  0.00%|        to the given data_encoding and then encoded to the underlying
   920|         0|            0|            0|  0.00%|        file using file_encoding. The intermediate data type
   921|         0|            0|            0|  0.00%|        will usually be Unicode but depends on the specified codecs.
   922|         0|            0|            0|  0.00%|
   923|         0|            0|            0|  0.00%|        Bytes read from the file are decoded using file_encoding and then
   924|         0|            0|            0|  0.00%|        passed back to the caller encoded using data_encoding.
   925|         0|            0|            0|  0.00%|
   926|         0|            0|            0|  0.00%|        If file_encoding is not given, it defaults to data_encoding.
   927|         0|            0|            0|  0.00%|
   928|         0|            0|            0|  0.00%|        errors may be given to define the error handling. It defaults
   929|         0|            0|            0|  0.00%|        to 'strict' which causes ValueErrors to be raised in case an
   930|         0|            0|            0|  0.00%|        encoding error occurs.
   931|         0|            0|            0|  0.00%|
   932|         0|            0|            0|  0.00%|        The returned wrapped file object provides two extra attributes
   933|         0|            0|            0|  0.00%|        .data_encoding and .file_encoding which reflect the given
   934|         0|            0|            0|  0.00%|        parameters of the same name. The attributes can be used for
   935|         0|            0|            0|  0.00%|        introspection by Python programs.
   936|         0|            0|            0|  0.00%|
   937|         0|            0|            0|  0.00%|    """
   938|         0|            0|            0|  0.00%|    if file_encoding is None:
   939|         0|            0|            0|  0.00%|        file_encoding = data_encoding
   940|         0|            0|            0|  0.00%|    data_info = lookup(data_encoding)
   941|         0|            0|            0|  0.00%|    file_info = lookup(file_encoding)
   942|         0|            0|            0|  0.00%|    sr = StreamRecoder(file, data_info.encode, data_info.decode,
   943|         0|            0|            0|  0.00%|                       file_info.streamreader, file_info.streamwriter, errors)
   944|         0|            0|            0|  0.00%|    # Add attributes to simplify introspection
   945|         0|            0|            0|  0.00%|    sr.data_encoding = data_encoding
   946|         0|            0|            0|  0.00%|    sr.file_encoding = file_encoding
   947|         0|            0|            0|  0.00%|    return sr
   948|         0|            0|            0|  0.00%|
   949|         0|            0|            0|  0.00%|### Helpers for codec lookup
   950|         0|            0|            0|  0.00%|
   951|         0|            0|            0|  0.00%|def getencoder(encoding):
   952|         0|            0|            0|  0.00%|
   953|         0|            0|            0|  0.00%|    """ Lookup up the codec for the given encoding and return
   954|         0|            0|            0|  0.00%|        its encoder function.
   955|         0|            0|            0|  0.00%|
   956|         0|            0|            0|  0.00%|        Raises a LookupError in case the encoding cannot be found.
   957|         0|            0|            0|  0.00%|
   958|         0|            0|            0|  0.00%|    """
   959|         0|            0|            0|  0.00%|    return lookup(encoding).encode
   960|         0|            0|            0|  0.00%|
   961|         0|            0|            0|  0.00%|def getdecoder(encoding):
   962|         0|            0|            0|  0.00%|
   963|         0|            0|            0|  0.00%|    """ Lookup up the codec for the given encoding and return
   964|         0|            0|            0|  0.00%|        its decoder function.
   965|         0|            0|            0|  0.00%|
   966|         0|            0|            0|  0.00%|        Raises a LookupError in case the encoding cannot be found.
   967|         0|            0|            0|  0.00%|
   968|         0|            0|            0|  0.00%|    """
   969|         0|            0|            0|  0.00%|    return lookup(encoding).decode
   970|         0|            0|            0|  0.00%|
   971|         0|            0|            0|  0.00%|def getincrementalencoder(encoding):
   972|         0|            0|            0|  0.00%|
   973|         0|            0|            0|  0.00%|    """ Lookup up the codec for the given encoding and return
   974|         0|            0|            0|  0.00%|        its IncrementalEncoder class or factory function.
   975|         0|            0|            0|  0.00%|
   976|         0|            0|            0|  0.00%|        Raises a LookupError in case the encoding cannot be found
   977|         0|            0|            0|  0.00%|        or the codecs doesn't provide an incremental encoder.
   978|         0|            0|            0|  0.00%|
   979|         0|            0|            0|  0.00%|    """
   980|         0|            0|            0|  0.00%|    encoder = lookup(encoding).incrementalencoder
   981|         0|            0|            0|  0.00%|    if encoder is None:
   982|         0|            0|            0|  0.00%|        raise LookupError(encoding)
   983|         0|            0|            0|  0.00%|    return encoder
   984|         0|            0|            0|  0.00%|
   985|         0|            0|            0|  0.00%|def getincrementaldecoder(encoding):
   986|         0|            0|            0|  0.00%|
   987|         0|            0|            0|  0.00%|    """ Lookup up the codec for the given encoding and return
   988|         0|            0|            0|  0.00%|        its IncrementalDecoder class or factory function.
   989|         0|            0|            0|  0.00%|
   990|         0|            0|            0|  0.00%|        Raises a LookupError in case the encoding cannot be found
   991|         0|            0|            0|  0.00%|        or the codecs doesn't provide an incremental decoder.
   992|         0|            0|            0|  0.00%|
   993|         0|            0|            0|  0.00%|    """
   994|         0|            0|            0|  0.00%|    decoder = lookup(encoding).incrementaldecoder
   995|         0|            0|            0|  0.00%|    if decoder is None:
   996|         0|            0|            0|  0.00%|        raise LookupError(encoding)
   997|         0|            0|            0|  0.00%|    return decoder
   998|         0|            0|            0|  0.00%|
   999|         0|            0|            0|  0.00%|def getreader(encoding):
  1000|         0|            0|            0|  0.00%|
  1001|         0|            0|            0|  0.00%|    """ Lookup up the codec for the given encoding and return
  1002|         0|            0|            0|  0.00%|        its StreamReader class or factory function.
  1003|         0|            0|            0|  0.00%|
  1004|         0|            0|            0|  0.00%|        Raises a LookupError in case the encoding cannot be found.
  1005|         0|            0|            0|  0.00%|
  1006|         0|            0|            0|  0.00%|    """
  1007|         0|            0|            0|  0.00%|    return lookup(encoding).streamreader
  1008|         0|            0|            0|  0.00%|
  1009|         0|            0|            0|  0.00%|def getwriter(encoding):
  1010|         0|            0|            0|  0.00%|
  1011|         0|            0|            0|  0.00%|    """ Lookup up the codec for the given encoding and return
  1012|         0|            0|            0|  0.00%|        its StreamWriter class or factory function.
  1013|         0|            0|            0|  0.00%|
  1014|         0|            0|            0|  0.00%|        Raises a LookupError in case the encoding cannot be found.
  1015|         0|            0|            0|  0.00%|
  1016|         0|            0|            0|  0.00%|    """
  1017|         0|            0|            0|  0.00%|    return lookup(encoding).streamwriter
  1018|         0|            0|            0|  0.00%|
  1019|         0|            0|            0|  0.00%|def iterencode(iterator, encoding, errors='strict', **kwargs):
  1020|         0|            0|            0|  0.00%|    """
  1021|         0|            0|            0|  0.00%|    Encoding iterator.
  1022|         0|            0|            0|  0.00%|
  1023|         0|            0|            0|  0.00%|    Encodes the input strings from the iterator using an IncrementalEncoder.
  1024|         0|            0|            0|  0.00%|
  1025|         0|            0|            0|  0.00%|    errors and kwargs are passed through to the IncrementalEncoder
  1026|         0|            0|            0|  0.00%|    constructor.
  1027|         0|            0|            0|  0.00%|    """
  1028|         0|            0|            0|  0.00%|    encoder = getincrementalencoder(encoding)(errors, **kwargs)
  1029|         0|            0|            0|  0.00%|    for input in iterator:
  1030|         0|            0|            0|  0.00%|        output = encoder.encode(input)
  1031|         0|            0|            0|  0.00%|        if output:
  1032|         0|            0|            0|  0.00%|            yield output
  1033|         0|            0|            0|  0.00%|    output = encoder.encode("", True)
  1034|         0|            0|            0|  0.00%|    if output:
  1035|         0|            0|            0|  0.00%|        yield output
  1036|         0|            0|            0|  0.00%|
  1037|         0|            0|            0|  0.00%|def iterdecode(iterator, encoding, errors='strict', **kwargs):
  1038|         0|            0|            0|  0.00%|    """
  1039|         0|            0|            0|  0.00%|    Decoding iterator.
  1040|         0|            0|            0|  0.00%|
  1041|         0|            0|            0|  0.00%|    Decodes the input strings from the iterator using an IncrementalDecoder.
  1042|         0|            0|            0|  0.00%|
  1043|         0|            0|            0|  0.00%|    errors and kwargs are passed through to the IncrementalDecoder
  1044|         0|            0|            0|  0.00%|    constructor.
  1045|         0|            0|            0|  0.00%|    """
  1046|         0|            0|            0|  0.00%|    decoder = getincrementaldecoder(encoding)(errors, **kwargs)
  1047|         0|            0|            0|  0.00%|    for input in iterator:
  1048|         0|            0|            0|  0.00%|        output = decoder.decode(input)
  1049|         0|            0|            0|  0.00%|        if output:
  1050|         0|            0|            0|  0.00%|            yield output
  1051|         0|            0|            0|  0.00%|    output = decoder.decode(b"", True)
  1052|         0|            0|            0|  0.00%|    if output:
  1053|         0|            0|            0|  0.00%|        yield output
  1054|         0|            0|            0|  0.00%|
  1055|         0|            0|            0|  0.00%|### Helpers for charmap-based codecs
  1056|         0|            0|            0|  0.00%|
  1057|         0|            0|            0|  0.00%|def make_identity_dict(rng):
  1058|         0|            0|            0|  0.00%|
  1059|         0|            0|            0|  0.00%|    """ make_identity_dict(rng) -> dict
  1060|         0|            0|            0|  0.00%|
  1061|         0|            0|            0|  0.00%|        Return a dictionary where elements of the rng sequence are
  1062|         0|            0|            0|  0.00%|        mapped to themselves.
  1063|         0|            0|            0|  0.00%|
  1064|         0|            0|            0|  0.00%|    """
  1065|         0|            0|            0|  0.00%|    return {i:i for i in rng}
  1066|         0|            0|            0|  0.00%|
  1067|         0|            0|            0|  0.00%|def make_encoding_map(decoding_map):
  1068|         0|            0|            0|  0.00%|
  1069|         0|            0|            0|  0.00%|    """ Creates an encoding map from a decoding map.
  1070|         0|            0|            0|  0.00%|
  1071|         0|            0|            0|  0.00%|        If a target mapping in the decoding map occurs multiple
  1072|         0|            0|            0|  0.00%|        times, then that target is mapped to None (undefined mapping),
  1073|         0|            0|            0|  0.00%|        causing an exception when encountered by the charmap codec
  1074|         0|            0|            0|  0.00%|        during translation.
  1075|         0|            0|            0|  0.00%|
  1076|         0|            0|            0|  0.00%|        One example where this happens is cp875.py which decodes
  1077|         0|            0|            0|  0.00%|        multiple character to \\u001a.
  1078|         0|            0|            0|  0.00%|
  1079|         0|            0|            0|  0.00%|    """
  1080|         0|            0|            0|  0.00%|    m = {}
  1081|         0|            0|            0|  0.00%|    for k,v in decoding_map.items():
  1082|         0|            0|            0|  0.00%|        if not v in m:
  1083|         0|            0|            0|  0.00%|            m[v] = k
  1084|         0|            0|            0|  0.00%|        else:
  1085|         0|            0|            0|  0.00%|            m[v] = None
  1086|         0|            0|            0|  0.00%|    return m
  1087|         0|            0|            0|  0.00%|
  1088|         0|            0|            0|  0.00%|### error handlers
  1089|         0|            0|            0|  0.00%|
  1090|         0|            0|            0|  0.00%|try:
  1091|         0|            0|            0|  0.00%|    strict_errors = lookup_error("strict")
  1092|         0|            0|            0|  0.00%|    ignore_errors = lookup_error("ignore")
  1093|         0|            0|            0|  0.00%|    replace_errors = lookup_error("replace")
  1094|         0|            0|            0|  0.00%|    xmlcharrefreplace_errors = lookup_error("xmlcharrefreplace")
  1095|         0|            0|            0|  0.00%|    backslashreplace_errors = lookup_error("backslashreplace")
  1096|         0|            0|            0|  0.00%|    namereplace_errors = lookup_error("namereplace")
  1097|         0|            0|            0|  0.00%|except LookupError:
  1098|         0|            0|            0|  0.00%|    # In --disable-unicode builds, these error handler are missing
  1099|         0|            0|            0|  0.00%|    strict_errors = None
  1100|         0|            0|            0|  0.00%|    ignore_errors = None
  1101|         0|            0|            0|  0.00%|    replace_errors = None
  1102|         0|            0|            0|  0.00%|    xmlcharrefreplace_errors = None
  1103|         0|            0|            0|  0.00%|    backslashreplace_errors = None
  1104|         0|            0|            0|  0.00%|    namereplace_errors = None
  1105|         0|            0|            0|  0.00%|
  1106|         0|            0|            0|  0.00%|# Tell modulefinder that using codecs probably needs the encodings
  1107|         0|            0|            0|  0.00%|# package
  1108|         0|            0|            0|  0.00%|_false = 0
  1109|         0|            0|            0|  0.00%|if _false:
  1110|         0|            0|            0|  0.00%|    import encodings
  1111|         0|            0|            0|  0.00%|
  1112|         0|            0|            0|  0.00%|### Tests
  1113|         0|            0|            0|  0.00%|
  1114|         0|            0|            0|  0.00%|if __name__ == '__main__':
  1115|         0|            0|            0|  0.00%|
  1116|         0|            0|            0|  0.00%|    # Make stdout translate Latin-1 output into UTF-8 output
  1117|         0|            0|            0|  0.00%|    sys.stdout = EncodedFile(sys.stdout, 'latin-1', 'utf-8')
  1118|         0|            0|            0|  0.00%|
  1119|         0|            0|            0|  0.00%|    # Have stdin translate Latin-1 input into UTF-8 input
  1120|         0|            0|            0|  0.00%|    sys.stdin = EncodedFile(sys.stdin, 'utf-8', 'latin-1')

v13.py took 12.19 for 100000 elements, N <= 1048576
